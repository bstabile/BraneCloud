/*
 * BraneCloud.Evolution.EC (Evolutionary Computation)
 * Copyright 2011 Bennett R. Stabile (BraneCloud.Evolution.net|com)
 * Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
 *
 * This is an independent conversion from Java to .NET of ...
 *
 * Sean Luke's ECJ project at GMU 
 * (Academic Free License v3.0): 
 * http://www.cs.gmu.edu/~eclab/projects/ecj
 *
 * Radical alteration was required throughout (including structural).
 * The author of ECJ cannot and MUST not be expected to support this fork.
 *
 * If you wish to create yet another fork, please use a different root namespace.
 * BraneCloud is a registered domain that will be used for name/schema resolution.
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks.Dataflow;
using BraneCloud.Evolution.EC.Breed;
using BraneCloud.Evolution.EC.Support;
using BraneCloud.Evolution.EC.Configuration;
using BraneCloud.Evolution.EC.Simple;
using BraneCloud.Evolution.EC.Util;

namespace BraneCloud.Evolution.EC.ES
{
    /// <summary> 
    /// MuCommaLambdaBreeder is a Breeder which, together with
    /// ESSelection, implements the (mu,Lambda) breeding strategy and gathers
    /// the comparison data you can use to implement a 1/5-rule mutation mechanism.
    /// 
    /// <p/>Evolution strategies breeders require a "mu" parameter and a "Lambda"
    /// parameter for each subpop.  "mu" refers to the number of parents
    /// from which the new population will be built.  "Lambda" refers to the
    /// number of children generated by the mu parents.  Subpopulation sizes
    /// will change as necessary to accommodate this fact in later generations.
    /// The only rule for initial subpop sizes is that they must be
    /// greater than or equal to the mu parameter for that subpop.
    /// 
    /// <p/>You can now set your initial subpop
    /// size to whatever you like, totally independent of Lambda and mu,
    /// as long as it is &gt;= mu.
    /// 
    /// <p/>MuCommaLambdaBreeder stores mu and Lambda values for each subpop
    /// in the population, as well as comparisons.  A comparison tells you
    /// if &gt;1/5, &lt;1/5 or =1/5 of the new population was better than its
    /// parents (the so-called evolution strategies "one-fifth rule".
    /// Although the comparisons are gathered, no mutation objects are provided
    /// which actually <i>use</i> them -- you're free to use them in any mutation
    /// objects you care to devise which requires them.
    /// 
    /// <p/>To do evolution strategies evolution, the
    /// breeding pipelines should contain at least one ESSelection selection method.
    /// While a child is being generated by the pipeline, the ESSelection object will return a parent
    /// from the pool of mu parents.  The particular parent is chosen round-robin, so all the parents
    /// will have an equal number of children.  It's perfectly fine to have more than one ESSelection
    /// object in the tree, or to call the same one repeatedly during the course of generating a child;
    /// all such objects will consistently return the same parent.  They only increment to the next
    /// parent in the pool of mu parents after the child has been created from the pipeline.  You can
    /// also mix ESSelection operators with other operators (like Tournament Selection).  But you ought
    /// to have <b>at least one</b> ESSelection operator in the pipeline -- else it wouldn't be Evolution
    /// Strategies, would it?
    /// 
    /// <p/><b>Parameters</b><br/>
    /// <table>
    /// <tr><td valign="top">es.Lambda.<i>subpop-num</i><br/>
    /// <font size="-1">int >= 0</font></td><td>Specifies the 'Lambda' parameter for the subpop.</td>
    /// </tr>
    /// <tr><td valign="top">es.mu.<i>subpop-num</i><br/>
    /// <font size="-1">int:  a multiple of "Lambda"</font></td><td>Specifies the 'mu' parameter for the subpop.</td>
    /// </tr>
    /// </table>
    /// </summary>	
    [Serializable]
    [ECConfiguration("ec.es.MuCommaLambdaBreeder")]
    public class MuCommaLambdaBreeder : Breeder
    {

        #region Constants

        public const string P_MU = "mu";
        public const string P_MU_FRACTION = "mu-fraction";
        public const string P_LAMBDA = "lambda";

        public const sbyte C_OVER_ONE_FIFTH_BETTER = 1;
        public const sbyte C_UNDER_ONE_FIFTH_BETTER = -1;
        public const sbyte C_EXACTLY_ONE_FIFTH_BETTER = 0;

        #endregion // Constants
        #region Properties

        public int[] Mu { get; set; }
        public int[] Lambda { get; set; }

        /** lambda should be no SMALLER than mu times this value. 
            This varies between (mu,lambda) (where it's 2) and
            (mu + lambda) (where it's 1).
        */
        public int MaximumMuLambdaDivisor { get; protected set; } = 2;

        public Population ParentPopulation { get; set; }

        public sbyte[] Comparison { get; set; }

        /// <summary>
        /// Modified by multiple threads, don't fool with this. 
        /// </summary>
        public int[] Count { get; set; }

        public int[] Children { get; set; }
        public int[] Parents { get; set; }

        // This is a DOUBLE ARRAY of ARRAYLISTS of <INDIVIDUALS>
        // Individuals are stored here by the breed pop chunk methods, and afterwards
        // we coalesce them into the new population. 
        // public ArrayList newIndividuals[/*subpop*/][/*thread*/];
        public IList<Individual>[][] NewIndividuals { get; set; }

        #endregion // Properties
        #region Setup

        public override void Setup(IEvolutionState state, IParameter paramBase)
        {
            // we're not using the paramBase
            var p = new Parameter(Initializer.P_POP).Push(Population.P_SIZE);
            // if size is wrong, we'll let Population complain about it -- for us, we'll just make 0-sized arrays and drop out.
            var size = state.Parameters.GetInt(p, null, 1);

            Mu = new int[size];
            Lambda = new int[size];
            Comparison = new sbyte[size];

            // load mu and Lambda data
            for (var x = 0; x < size; x++)
            {
                IParameter pp = new Parameter(Initializer.P_POP).Push(Population.P_SUBPOP).Push("" + x)
                    .Push(Subpopulation.P_SUBPOPSIZE);
                int ppval = state.Parameters.GetInt(pp, null, 1);

                // we have a lambda
                if (state.Parameters.ParameterExists(ESDefaults.ParamBase.Push(P_LAMBDA).Push("" + x), null)) 
                {
                    Lambda[x] = state.Parameters.GetInt(ESDefaults.ParamBase.Push(P_LAMBDA).Push("" + x), null, 1);
                    if (Lambda[x] == 0)
                        state.Output.Error("Lambda must be an integer >= 1",
                            ESDefaults.ParamBase.Push(P_LAMBDA).Push("" + x));
                }
                else
                {
                    state.Output.Warning(
                        "lambda not specified for subpopulation " + x +
                        ", setting it to the subopulation size, that is, " + ppval + ".",
                        ESDefaults.ParamBase.Push(P_LAMBDA).Push("" + x), null);
                    Lambda[x] = ppval;
                    if (Lambda[x] == 0)
                        state.Output.Error("Subpouplation Size must be >= 1", pp, null);
                }

                // we defined mu
                if (state.Parameters.ParameterExists(ESDefaults.ParamBase.Push(P_MU).Push("" + x), null))
                {
                    // did we also define a mu-fraction?
                    if (state.Parameters.ParameterExists(ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x), null))
                        state.Output.Warning(
                            "Defined both a mu and mu-fraction for subpopulation " + x + ".  Only mu will be used. ",
                            ESDefaults.ParamBase.Push(P_MU).Push("" + x),
                            ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x));

                    Mu[x] = state.Parameters.GetInt(ESDefaults.ParamBase.Push(P_MU).Push("" + x), null, 1);
                    if (Mu[x] == 0)
                        state.Output.Error("mu must be an integer >= 1", ESDefaults.ParamBase.Push(P_MU).Push("" + x));
                    else if (Lambda[x] % Mu[x] != 0)
                    {
                        if (Mu[x] > Lambda[x] / MaximumMuLambdaDivisor)
                        {
                            state.Output.Warning("mu (" + Mu[x] + ") for subpopulation " + x +
                                                 " is greater than lambda (" + Lambda[x] + ") / " +
                                                 MaximumMuLambdaDivisor +
                                                 ".  Mu will be set to half of lambda, that is, " +
                                                 Lambda[x] / MaximumMuLambdaDivisor + ".");
                            Mu[x] = Lambda[x] / MaximumMuLambdaDivisor;
                        }

                        if (Lambda[x] % Mu[x] != 0) // check again
                            state.Output.Error("mu must be a divisor of lambda",
                                ESDefaults.ParamBase.Push(P_MU).Push("" + x));
                    }
                    else if (Mu[x] > ppval)
                    {
                        state.Output.Warning(
                            "mu is presently > the initial subpopulation size.  Mu will be set to the subpopulation size, that is, " +
                            ppval + ".", ESDefaults.ParamBase.Push(P_MU).Push("" + x), null);
                        Mu[x] = ppval;
                    }
                }
                else if (state.Parameters.ParameterExists(ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x),
                    null)) // we defined mu in terms of a fraction
                {
                    double mufrac = state.Parameters.GetDoubleWithMax(
                        ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x), null, 0.0,
                        1.0 / MaximumMuLambdaDivisor);
                    if (mufrac < 0.0)
                        state.Output.Fatal(
                            "Mu-Fraction must be a value between 0.0 and " + 1.0 / MaximumMuLambdaDivisor,
                            ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x), null);

                    int m = (int) Math.Max(Lambda[x] * mufrac, 1.0);
                    Mu[x] = m;
                    // find the largest divisor of lambda[x] which is <= m. This is ugly
                    double val = Lambda[x] / (double) Mu[x];
                    while (val != (int) val)
                    {
                        Mu[x]--;
                        val = Lambda[x] / (double) Mu[x];
                    }
                    state.Output.Message(
                        "Mu-Fraction " + mufrac + " yields a mu of " + m + ", adjusted to " + Mu[x]);
                }
                else
                    state.Output.Fatal("Neither a Mu or a Mu-Fraction was provided for subpopulation " + x,
                        ESDefaults.ParamBase.Push(P_MU).Push("" + x),
                        ESDefaults.ParamBase.Push(P_MU_FRACTION).Push("" + x));
            }
            state.Output.ExitIfErrors();
        }

        #endregion // Setup
        #region Operations

        ///// <summary>
        ///// Sets all subpops in pop to the expected Lambda size.  Does not fill new slots with individuals. 
        ///// </summary>
        //public virtual Population SetToLambda(Population pop, IEvolutionState state)
        //{
        //    for (var x = 0; x < pop.Subpops.Length; x++)
        //    {
        //        var s = Lambda[x];
        //        // check to see if the array's not the right size
        //        if (pop.Subpops[x].Individuals.Length != s)
        //        // need to increase
        //        {
        //            var newinds = new Individual[s];
        //            Array.Copy(pop.Subpops[x].Individuals, 0, newinds, 0,
        //                s < pop.Subpops[x].Individuals.Length ? s : pop.Subpops[x].Individuals.Length);
        //            pop.Subpops[x].Individuals = newinds;
        //        }
        //    }
        //    return pop;
        //}

        public override Population BreedPopulation(IEvolutionState state)
        {
            // Complete 1/5 statistics for last population

            if (ParentPopulation != null)
            {
                // Only go from 0 to Lambda-1, as the remaining individuals may be parents.
                // A child C's parent's index I is equal to C / Mu[subpop].
                for (var x = 0; x < state.Population.Subpops.Count; x++)
                {
                    var numChildrenBetter = 0;
                    for (var i = 0; i < Lambda[x]; i++)
                    {
                        var parent = i / (Lambda[x] / Mu[x]); // note integer division
                        if (state.Population.Subpops[x].Individuals[i].Fitness.BetterThan(ParentPopulation.Subpops[x].Individuals[parent].Fitness))
                            numChildrenBetter++;
                    }
                    if (numChildrenBetter > Lambda[x] / 5.0) // note double division
                        Comparison[x] = C_OVER_ONE_FIFTH_BETTER;
                    else if (numChildrenBetter < Lambda[x] / 5.0) // note double division
                        Comparison[x] = C_UNDER_ONE_FIFTH_BETTER;
                    else
                        Comparison[x] = C_EXACTLY_ONE_FIFTH_BETTER;
                }
            }

            // load the parent population
            ParentPopulation = state.Population;

            // MU COMPUTATION

            // At this point we need to do load our population info
            // and make sure it jibes with our mu info

            // the first issue is: is the number of subpops
            // equal to the number of mu's?

            if (Mu.Length != state.Population.Subpops.Count) // uh oh
                state.Output.Fatal("For some reason the number of subpops is different than was specified in the file (conflicting with Mu and Lambda storage).", null);

            // next, load our population, make sure there are no subpops smaller than the mu's
            for (var x = 0; x < state.Population.Subpops.Count; x++)
            {
                if (state.Population.Subpops[0].Individuals.Count < Mu[x])
                    state.Output.Error("Subpopulation " + x + " must be a multiple of the equivalent mu (that is, " + Mu[x] + ").");
            }
            state.Output.ExitIfErrors();


            // sort evaluation to get the Mu best of each subpop

            foreach (Subpopulation s in state.Population.Subpops)
            {
                s.Individuals.SortByFitnessDescending();
            }

            // now the subpops are sorted so that the best individuals
            // appear in the lowest indexes.

            Population newpop = state.Population.EmptyClone();

            // create the count array
            Count = new int[state.BreedThreads];

            // divvy up the Lambda individuals to create

            // how many threads do we really need?  No more than the maximum number of individuals in any subpopulation
            int numThreads = 0;
            for (int x = 0; x < state.Population.Subpops.Count; x++)
                numThreads = Math.Max(numThreads, Lambda[x]);
            numThreads = Math.Min(numThreads, state.BreedThreads);
            if (numThreads < state.BreedThreads)
                state.Output.WarnOnce("Largest lambda size (" + numThreads + ") is smaller than number of breedthreads (" + state.BreedThreads +
                                      "), so fewer breedthreads will be created.");

            NewIndividuals = TensorFactory.Create<IList<Individual>>(state.Population.Subpops.Count, numThreads);

            int[][] numinds = TensorFactory.Create<int>(numThreads, state.Population.Subpops.Count);
            int[][] from = TensorFactory.Create<int>(numThreads, state.Population.Subpops.Count);

            for (int x = 0; x < state.Population.Subpops.Count; x++)
            {
                for (int thread = 0; thread < numThreads; thread++)
                    NewIndividuals[x][thread].Clear();

                int length = Lambda[x];

                // we will have some extra individuals.  We distribute these among the early subpopulations
                int individualsPerThread = length / numThreads;  // integer division
                int slop = length - numThreads * individualsPerThread;
                int currentFrom = 0;

                for (int y = 0; y < numThreads; y++)
                {
                    if (slop > 0)
                    {
                        numinds[y][x] = individualsPerThread + 1;
                        slop--;
                    }
                    else
                        numinds[y][x] = individualsPerThread;

                    if (numinds[y][x] == 0)
                    {
                        state.Output.WarnOnce("More threads exist than can be used to breed some subpopulations (first example: subpopulation " + x + ")");
                    }

                    from[y][x] = currentFrom;
                    currentFrom += numinds[y][x];
                }
            }

            //for (var y = 0; y < state.BreedThreads; y++)
            //    for (var x = 0; x < state.Population.Subpops.Length; x++)
            //    {
            //        // figure numinds
            //        if (y < state.BreedThreads - 1)
            //            // not last one
            //            numinds[y][x] = Lambda[x] / state.BreedThreads;
            //        // in case we're slightly off in division
            //        else
            //            numinds[y][x] = Lambda[x] / state.BreedThreads + (Lambda[x] - (Lambda[x] / state.BreedThreads) * state.BreedThreads);

            //        // figure from
            //        from[y][x] = (Lambda[x] / state.BreedThreads) * y;
            //    }

            if (numThreads == 1)
            {
                BreedPopChunk(newpop, state, numinds[0], from[0], 0);
            }
            else
            {
                ParallelBreeding(state, newpop, from, numinds, this);
            }

            // Coalesce
            for (int subpop = 0; subpop < state.Population.Subpops.Count; subpop++)
            {
                IList<Individual> newpopinds = newpop.Subpops[subpop].Individuals;
                for (int thread = 0; thread < numThreads; thread++)
                {
                    ((List<Individual>)newpopinds).AddRange(NewIndividuals[subpop][thread]);
                }
            }

            return PostProcess(newpop, state.Population, state);
        }

        void ParallelBreeding(IEvolutionState state, Population newpop, int[][] origin, int[][] numinds, MuCommaLambdaBreeder breeder)
        {
            // BRS: TPL DataFlow is cleaner and safer than using raw threads.

            // Limit the concurrency in case the user has gone overboard!
            var maxDegree = Math.Min(Environment.ProcessorCount, state.BreedThreads);
            var options = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = maxDegree };

            Action<BreederThread> act = t => t.Run();
            var actionBlock = new ActionBlock<BreederThread>(act, options);

            for (var i = 0; i < state.BreedThreads; i++)
            {
                var runnable = new BreederThread
                {
                    ThreadNum = i,
                    State = state,
                    NewPop = newpop,
                    NumInds = numinds[i],
                    From = origin[i],
                    Breeder = breeder,
                };
                actionBlock.Post(runnable);
            }
            actionBlock.Complete();
            actionBlock.Completion.Wait();
        }

        /// <summary>
        /// A hook for Mu+Lambda, not used in Mu,Lambda. 
        /// </summary>        
        public virtual Population PostProcess(Population newpop, Population oldpop, IEvolutionState state)
        {
            return newpop;
        }

        /// <summary>
        /// A private helper function for breedPopulation which breeds a chunk
        /// of individuals in a subpop for a given thread.
        /// Although this method is declared
        /// public (for the benefit of a private helper class in this file),
        /// you should not call it. 
        /// </summary>        
        public override void BreedPopChunk(Population newpop, IEvolutionState state, int[] numinds, int[] from, int threadnum)
        {
            for (var subpop = 0; subpop < newpop.Subpops.Count; subpop++)
            {
                IList<Individual> putHere = NewIndividuals[subpop][threadnum];

                // reset the appropriate count slot  -- this used to be outside the for-loop, a bug
                // I believe
                Count[threadnum] = 0;

                var bp = (BreedingSource)newpop.Subpops[subpop].Species.Pipe_Prototype.Clone();

                // check to make sure that the breeding pipeline produces
                // the right kind of individuals.  Don't want a mistake there! :-)
                if (!bp.Produces(state, newpop, subpop, threadnum))
                {
                    state.Output.Fatal("The Breeding Pipeline of subpop " + subpop
                        + " does not produce individuals of the expected species "
                        + newpop.Subpops[subpop].Species.GetType().FullName + " or fitness "
                        + newpop.Subpops[subpop].Species.F_Prototype);
                }
                bp.PrepareToProduce(state, subpop, threadnum);
                if (Count[threadnum] == 0)
                    // the ESSelection didn't set it to nonzero to inform us of his existence
                    state.Output.WarnOnce("Whoa!  Breeding Source for subpop " + subpop
                        + " doesn't have an ESSelection, but is being used by MuCommaLambdaBreeder or MuPlusLambdaBreeder."
                        + "  That's probably not right.");
                // reset again
                Count[threadnum] = 0;

                // start breedin'!

                var upperbound = from[subpop] + numinds[subpop];
                for (var x = from[subpop]; x < upperbound; x++)
                {
                    var newMisc = newpop.Subpops[subpop].Species.BuildMisc(state, subpop, threadnum);
                    if (bp.Produce(1, 1, subpop, putHere, state, threadnum, newMisc) != 1)
                        state.Output.Fatal("Whoa! Breeding Source for subpop " + subpop
                            + " is not producing one individual at a time, as is required by the MuLambda strategies.");

                    // increment the count
                    Count[threadnum]++;
                }
                bp.FinishProducing(state, subpop, threadnum);
            }
        }
        
        #endregion // Operations
     }
}