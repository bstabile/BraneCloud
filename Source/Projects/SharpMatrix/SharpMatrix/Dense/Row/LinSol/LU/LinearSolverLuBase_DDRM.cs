using System;
using BraneCloud.Evolution.EC.MatrixLib.Data;
using BraneCloud.Evolution.EC.MatrixLib.Dense.Row.Decomposition.LU;
using BraneCloud.Evolution.EC.MatrixLib.Interfaces.Decomposition;

namespace BraneCloud.Evolution.EC.MatrixLib.Dense.Row.LinSol.LU
{
    //package org.ejml.dense.row.linsol.lu;

/**
 * @author Peter Abeles
 */
    public abstract class LinearSolverLuBase_DDRM : LinearSolverAbstract_DDRM
    {

        protected LUDecompositionBase_DDRM decomp;

        public LinearSolverLuBase_DDRM(LUDecompositionBase_DDRM decomp)
        {
            this.decomp = decomp;

        }

        public override bool setA(DMatrixRMaj A)
        {
            _setA(A);

            return decomp.decompose(A);
        }


        public override /**/ double quality()
        {
            return decomp.quality();
        }


        public override void invert(DMatrixRMaj A_inv)
        {
            double[] vv = decomp._getVV();
            DMatrixRMaj LU = decomp.getLU();

            if (A_inv.numCols != LU.numCols || A_inv.numRows != LU.numRows)
                throw new ArgumentException("Unexpected matrix dimension");

            int n = A.numCols;

            double[] dataInv = A_inv.data;

            for (int j = 0; j < n; j++)
            {
                // don't need to change inv into an identity matrix before hand
                for (int i = 0; i < n; i++) vv[i] = i == j ? 1 : 0;
                decomp._solveVectorInternal(vv);
//            for( int i = 0; i < n; i++ ) dataInv[i* n +j] = vv[i];
                int index = j;
                for (int i = 0; i < n; i++, index += n) dataInv[index] = vv[i];
            }
        }

        /**
         * This attempts to improve upon the solution generated by account
         * for numerical imprecisions.  See numerical recipes for more information.  It
         * is assumed that solve has already been run on 'b' and 'x' at least once.
         *
         * @param b A matrix. Not modified.
         * @param x A matrix. Modified.
         */
        public void improveSol(DMatrixRMaj b, DMatrixRMaj x)
        {
            if (b.numCols != x.numCols)
            {
                throw new ArgumentException("bad shapes");
            }

            double[] dataA = A.data;
            double[] dataB = b.data;
            double[] dataX = x.data;

            int nc = b.numCols;
            int n = b.numCols;

            double[] vv = decomp._getVV();

//        BigDecimal sdp = new BigDecimal(0);
            for (int k = 0; k < nc; k++)
            {
                for (int i = 0; i < n; i++)
                {
                    // *NOTE* in the book this is a long double.  extra precision might be required
                    double sdp = -dataB[i * nc + k];
//                BigDecimal sdp = new BigDecimal(-dataB[ i * nc + k]);
                    for (int j = 0; j < n; j++)
                    {
                        sdp += dataA[i * n + j] * dataX[j * nc + k];
//                    sdp = sdp.add( BigDecimal.valueOf(dataA[i* n +j] * dataX[ j * nc + k]));
                    }
                    vv[i] = sdp;
//                vv[i] = sdp.doubleValue();
                }
                decomp._solveVectorInternal(vv);
                for (int i = 0; i < n; i++)
                {
                    dataX[i * nc + k] -= vv[i];
                }
            }
        }

        public override bool modifiesA()
        {
            return false;
        }

        public override bool modifiesB()
        {
            return false;
        }

        public override DecompositionInterface<DMatrixRMaj> getDecomposition()
        {
            return decomp;
        }
    }
}