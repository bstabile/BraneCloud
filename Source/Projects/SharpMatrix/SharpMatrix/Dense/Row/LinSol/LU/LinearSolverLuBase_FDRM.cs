using System;
using SharpMatrix.Data;
using SharpMatrix.Dense.Row.Decomposition.LU;
using SharpMatrix.Interfaces.Decomposition;

namespace SharpMatrix.Dense.Row.LinSol.LU
{
    //package org.ejml.dense.row.linsol.lu;
/**
 * @author Peter Abeles
 */
    public abstract class LinearSolverLuBase_FDRM : LinearSolverAbstract_FDRM
    {

        protected LUDecompositionBase_FDRM decomp;

        public LinearSolverLuBase_FDRM(LUDecompositionBase_FDRM decomp)
        {
            this.decomp = decomp;

        }

        public override bool setA(FMatrixRMaj A)
        {
            _setA(A);

            return decomp.decompose(A);
        }

        public override /**/ double quality()
        {
            return decomp.quality();
        }

        public override void invert(FMatrixRMaj A_inv)
        {
            float[] vv = decomp._getVV();
            FMatrixRMaj LU = decomp.getLU();

            if (A_inv.numCols != LU.numCols || A_inv.numRows != LU.numRows)
                throw new ArgumentException("Unexpected matrix dimension");

            int n = A.numCols;

            float[] dataInv = A_inv.data;

            for (int j = 0; j < n; j++)
            {
                // don't need to change inv into an identity matrix before hand
                for (int i = 0; i < n; i++) vv[i] = i == j ? 1 : 0;
                decomp._solveVectorInternal(vv);
//            for( int i = 0; i < n; i++ ) dataInv[i* n +j] = vv[i];
                int index = j;
                for (int i = 0; i < n; i++, index += n) dataInv[index] = vv[i];
            }
        }

        /**
         * This attempts to improve upon the solution generated by account
         * for numerical imprecisions.  See numerical recipes for more information.  It
         * is assumed that solve has already been run on 'b' and 'x' at least once.
         *
         * @param b A matrix. Not modified.
         * @param x A matrix. Modified.
         */
        public void improveSol(FMatrixRMaj b, FMatrixRMaj x)
        {
            if (b.numCols != x.numCols)
            {
                throw new ArgumentException("bad shapes");
            }

            float[] dataA = A.data;
            float[] dataB = b.data;
            float[] dataX = x.data;

            int nc = b.numCols;
            int n = b.numCols;

            float[] vv = decomp._getVV();

//        BigDecimal sdp = new BigDecimal(0);
            for (int k = 0; k < nc; k++)
            {
                for (int i = 0; i < n; i++)
                {
                    // *NOTE* in the book this is a long float.  extra precision might be required
                    float sdp = -dataB[i * nc + k];
//                BigDecimal sdp = new BigDecimal(-dataB[ i * nc + k]);
                    for (int j = 0; j < n; j++)
                    {
                        sdp += dataA[i * n + j] * dataX[j * nc + k];
//                    sdp = sdp.add( BigDecimal.valueOf(dataA[i* n +j] * dataX[ j * nc + k]));
                    }
                    vv[i] = sdp;
//                vv[i] = sdp.floatValue();
                }
                decomp._solveVectorInternal(vv);
                for (int i = 0; i < n; i++)
                {
                    dataX[i * nc + k] -= vv[i];
                }
            }
        }

        public override bool modifiesA()
        {
            return false;
        }

        public override bool modifiesB()
        {
            return false;
        }

        public override DecompositionInterface<FMatrixRMaj> getDecomposition()
        {
            return decomp;
        }
    }
}